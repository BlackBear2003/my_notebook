# CAS(Compare and Set)

****

> 摘要——**没有 CAS 和 volatile 就没有 J.U.C 并发包**。

## 乐观锁和悲观锁回顾

- 悲观锁是一种悲观思想，认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
  - synchronized 关键字和 Lock 接口的实现类就是悲观锁。

- 乐观锁是一种乐观思想，认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在提交修改的时候去判断一下，在此之前有没有其他的线程也修改了这个数据：
  - 如果其他的线程还没有提交修改，那么当前线程就将自己修改的数据成功写入；
  - 如果其他的线程已经提交了修改，则当前线程会根据不同的实现方式执行不同的操作（例如报错或者自动重试）。

换句话说，乐观锁的**目的就是在不使用锁（悲观锁）的情况下保证线程安全。**

乐观锁在 Java 中是采用 CAS 算法实现的，J.U.C 包中的原子类就是通过 CAS 算法来实现了乐观锁。

使用这种 CAS 算法的代码也常被称为 **无锁** 编程（Lock-Free）。

## 介绍

CAS是一种算法，并不是一个具体的什么锁。事实上，现代处理器基本都已经内置了实现 CAS 的指令，比如 x86 指令集上的 `CAMPXCHG`。

JMM 中不仅有主内存，每个线程还有各自的本地内存。每个线程会先更新自己的本地内存，然后再同步更新到主内存。

> 那如果多个线程都想要同步更新到主内存怎么办呢？

这就是CAS发挥作用的地方了，当多个线程尝试使用 CAS 同时更新主内存中的同一个变量时，只有一个线程可以成功更新变量的值，其他的线程都会失败，失败的线程并不会挂起，而是会自旋重试。

## 实现

如何发挥作用呢？看英文**compare and set**实际上就已经告诉我们了：**比较然后设置**。

首先线程先读取需要读写的某个变量的值，然后比较**当前该变量的值**和**该变量原来应该有的值**。

具体是如何实现的？还是用一个例子来介绍吧

![](E:\MarkDown\my_notebook\java并发\CAS\cas1.png)

## CAS 存在的三大问题

看起来 CAS 好像很不错，高效地解决了并发问题，但事实上，CAS 仍然存在三大问题：

- ABA 问题
- 循环时间长开销大
- 只能保证一个共享变量的原子操作

### ABA问题

所谓 ABA 问题就出现 ”如果没有发生变化才会进行更新" 这里，假设线程 T1 想要修改变量 var，读取到 var = A，然后，线程上下文切换，var 被线程 T2 修改成了 B，然后 T2 又将其修改回了 A，那么当 T1 去进行比较检查时会发现 var 的值并没有发生变化，还是 A，但是实际上，var 已经被改过两次了。

![](E:\MarkDown\my_notebook\java并发\CAS\1640878096-FQvQUG-image.png)

针对线程 T1 来说，它第一次看见的 A 和第二次看见的 A 实际上并不是同一个 A。

那么很容易想到，如果想要解决这个 ABA 问题，我们只需要对这些值进行一下标识，即使用版本号，在变量值前面追加上版本号，每次变量更新的时候把版本号加 1，那么 A→B→A 就会变成 1A→2B→3A。

![](E:\MarkDown\my_notebook\java并发\CAS\1640878105-ovQGXN-image.png)

### 只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们确实可以使用循环 CAS 的方式来高效地保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性了。

那如果想要同时原子地修改多个共享变量怎么办呢？

有两种方法：

1. 最简单的一种：锁

2. 第二种无锁方法，就是把多个共享变量合并成一个共享变量再来操作。比如，有两个共享变量 a = 1 和 b = 2，合并一下 ab = 12，然后用 CAS 来操作 ab。

> 同样地，针对这个问题，从 Java 1.5 开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，这样我们就可以把多个变量封装在一个对象里来进行 CAS 操作。

### 循环时间开销大

至于如何解决循环时间开销大的问题，由于涉及的知识比较底层，了解就好~

> 其解决办法就是使 JVM 支持底层指令 pause，这个指令的功能就是当自旋失败时让 CPU 睡眠一小段时间再继续自旋，其有两个作用：
>
> 1）降低读操作的频率；
>
> 2）避免在退出循环的时候因 内存顺序冲突（Memory OrderViolation） 而引起 CPU 流水线被清空（CPU PipelineFlush）。
>
> 所谓内存顺序，就是 CPU 访问内存的顺序。对于 CAS 这种无锁方式来说，不同于 volatile 和 synchronized，它没有任何的 Happens-before 原则来约束重排序行为，所以在这种情况下可以说 CPU 是在乱序执行的。
>
> 当自旋锁快要释放的时候，持锁线程会有一个 store 命令，而外面自旋等待的线程会发出各自的 load 命令，如果发生重排序导致 load 出现在 store 之前，此时会进行流水线清空再重排序，显然这样会严重影响 CPU 的效率，而 pause 可以减少并行 load 的数量，从而减少重排序所耗费的时间。
>